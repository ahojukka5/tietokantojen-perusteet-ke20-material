---
path: '/luku-5/2'
title: 'Tietokannan rakenne'
hidden: false
---

*Periaate 1*:
Kaikki saman tyyppiset rivit ovat samassa
taulussa tietokannassa.
Taulussa ei ole saman tyyppistä tietoa
useassa sarakkeessa.

Tämä periaate helpottaa tietokannan käsittelyä
SQL-komentojen avulla,
koska voimme olettaa komennoissa,
että tietokannan taulut ja sarakkeet ovat kiinteät.

Mitä käy, jos emme noudata tätä periaatetta?
Seuraavassa on kaksi esimerkkiä asiasta.

## Esimerkki 1

Tallennamme tietokantaan elokuvia ja
päätämme jakaa elokuvat tauluihin niiden vuoden mukaan.
Esimerkiksi tauluissa `Elokuvat1937` ja `Elokuvat1940`
on vuosina 1937 ja 1940 julkaistut elokuvat:

```
sqlite> SELECT * FROM Elokuvat1937;
id          nimi      
----------  ----------
1           Lumikki         
```

```
sqlite> SELECT * FROM Elokuvat1940;
id          nimi      
----------  ----------
1           Fantasia
2           Pinocchio
```

Tämä tietokanta toimii niin kauan, kuin haluamme hakea
vain tietyn vuoden elokuvia.
Esimerkiksi seuraava kysely hakee vuoden 1940 elokuvat:

```sql
SELECT nimi FROM Elokuvat1940;
```

Kuitenkin tilanne muuttuu hankalaksi heti,
jos haluamme käsitellä elokuvia jotenkin muuten.
Esimerkiksi jos haluamme hakea kaikki elokuvat
vuosilta 1940–1950, tarvitsemme useita kyselyjä:

```sql
SELECT nimi FROM Elokuvat1940;
SELECT nimi FROM Elokuvat1941;
SELECT nimi FROM Elokuvat1942;
...
SELECT nimi FROM Elokuvat1950;
```

Olisikin käytännössä todella huono idea tehdä oma
taulu jokaiselle vuodelle.
Parempi tapa on tallentaa kaikki elokuvat samaan tauluun:

```
sqlite> SELECT * FROM Elokuvat;
id          nimi        vuosi     
----------  ----------  ----------
1           Lumikki     1937      
2           Fantasia    1940      
3           Pinocchio   1940      
4           Dumbo       1941      
5           Bambi       1942    
```

Nyt voimme hakea yhtä helposti vuoden 1940 elokuvat tai
kaikki elokuvat vuosina 1940–1950:

```sql
SELECT nimi FROM Elokuvat WHERE vuosi=1940;
```

```sql
SELECT nimi FROM Elokuvat WHERE vuosi BETWEEN 1940 AND 1950;
```

## Esimerkki 2

Tallennamme tietokantaan opiskelijoiden tenttituloksia.
Tentissä on neljä tehtävää, joista voi saada 0–6 pistettä.
Teemme jokaisen tehtävän pisteille oman sarakkeen:

```
sqlite> SELECT * FROM Tulokset;
id          opiskelija_id  pisteet1    pisteet2    pisteet3    pisteet4  
----------  -------------  ----------  ----------  ----------  ----------
1           123            6           5           1           4         
2           172            3           6           6           6         
3           151            6           4           0           6     
```

Tämän suunnittelun ongelmana on, että meidän on vaivalloista
käsitellä pisteitä sarake kerrallaan.
Esimerkiksi jos haluamme laskea jokaisen opiskelijoiden yhteispisteet,
meidän täytyy listata kaikki sarakkeet kyselyssä:

```sql
SELECT opiskelija_id, pisteet1+pisteet2+pisteet3+pisteet4 FROM Tulokset;
```

Lisäksi taulun rakenne olettaa, että tehtäviä on tasan neljä,
mikä rajoittaa sen käyttökelpoisuutta.
Jos seuraavassa tentissä onkin viisi tehtävää,
joudumme lisäämään uuden sarakkeen ja muuttamaan kaikkia
taulua käsitteleviä SQL-komentoja.

Parempi ratkaisu on tallentaa tulokset tauluun niin,
että joka rivillä on yhden tehtävän pisteet:

```
sqlite> SELECT * FROM Tulokset;
id          opiskelija_id  tehtava_id  pisteet   
----------  -------------  ----------  ----------
1           123            1           6         
2           123            2           5         
3           123            3           1         
4           123            4           4         
5           172            1           3         
6           172            2           6         
7           172            3           6         
8           172            4           6         
9           151            1           6         
10          151            2           4         
11          151            3           0         
12          151            4           6
```

Nyt voimme hakea kunkin opiskelijan yhteispisteet näin:

```sql
SELECT opiskelija_id, SUM(pisteet) FROM Tulokset GROUP BY opiskelija_id;
```

Tämä on _yleiskäyttöinen_ kysely eli se toimii yhtä hyvin
riippumatta tehtävien määrästä.
Pystyimme hyödyntämään summan laskemisessa funktiota `SUM`
sen sijaan, että meidän tulisi listata tehtävät itse.

Huomaa, että muutoksen seurauksena taulun rivien määrä kasvoi selvästi.
Tätä ei kannata kuitenkaan hätkähtää:
tietokantajärjestelmät on toteutettu niin,
että ne toimivat hyvin, vaikka olisi paljon rivejä.
