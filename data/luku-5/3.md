---
path: '/luku-5/3'
title: 'Listojen toteutus'
hidden: false
---

*Periaate 2*:
Jokaisessa sarakkeessa on jokin yksittäinen tieto,
mutta ei listaa tiedoista.
Lista tallennetaan erilliseen tauluun niin,
että jokainen alkio on oma rivinsä.

Tässä näkyy tietokantojen ja olio-ohjelmoinnin ero.
Ohjelmoinnissa voi mainiosti olla olio,
jonka sisällä on lista muita olioita.
Tietokannoissa kuitenkaan näin ei ole tapana tehdä,
vaan listat tallennetaan erikseen.

## Esimerkki 1

Jatketaan edellisen aliluvun esimerkkiä,
jossa tallennamme tietokantaan opiskelijoiden
tenttituloksia.
Mitä käy, jos tallennammekin pisteet listana
samaan sarakkeeseen?

Voimme tallentaa pisteet samaan sarakkeeseen
merkkijonona pilkuilla erotettuina:

```
sqlite> SELECT * FROM Tulokset;
id          opiskelija_id  pisteet   
----------  -------------  ----------
1           123            6,5,1,4   
2           172            3,6,6,6   
3           151            6,4,0,6  
```

Tällöin kuitenkin pisteiden käsittely SQL:ssä
on mutkikasta.
Jos haluamme laskea jokaisen opiskelijan yhteispisteet,
joudumme ensin erottamaan pisteet merkkijonosta:

```sql
SELECT SUBSTR(pisteet,1,1)+
       SUBSTR(pisteet,3,1)+
       SUBSTR(pisteet,5,1)+
       SUBSTR(pisteet,7,1) FROM Tulokset;
```

Tässä funktio `SUBSTR` hakee merkkijonon osajonon tietystä kohdasta.
Kyselystä tulisi vielä hankalampi, jos pistemäärä voisi muodostua
useasta numerosta.

Vaikka voimme teoriassa käsitellä listaa merkkijonofunktioiden
avulla, toimimme nyt selkeästi vastoin SQL-kielen käytäntöjä.
Listan tallentaminen merkkijonona ei ole hyvä idea,
jos meidän pitää mitenkään käsitellä listan sisältöä SQL-komennoissa.

## Esimerkki 2

Usein tarve listalle tulee siitä, että haluamme viitata
tietokannan taulun rivistä useaan toisen taulun riviin.
Esimerkiksi järjestelmässä on käyttäjiä ja jokaisella
on lista katsotuista videoista.

Jälleen huono ratkaisu olisi tallentaa listat
merkkijonoina:

```
sqlite> SELECT * FROM Kayttajat;
id          nimi        videot    
----------  ----------  ----------
1           Anna        2,4,5     
2           Maija       1,4       
3           Pasi        1,3,5     
```

```
sqlite> SELECT * FROM Videot;
id          nimi          
----------  --------------
1           SQL Tutorial 1
2           SQL Tutorial 2
3           SQL Tutorial 3
4           Karpon parhaat
5           NHK Opening   
```

Tällaisesta tietokannasta olisi vaivalloista
yrittää hakea mitään videoiden katsomista koskevaa tietoa,
kuten montako kertaa kutakin videota on katsottu.
Olisi myös hankalaa yrittää lisätä käyttäjälle uusi katsottu video.

Parempi ratkaisu on tallentaa listat erikseen.
Koska käyttäjä voi katsoa monia videoita ja toisaalta
tiettyä videota voi katsoa useita käyttäjiä,
tarvitsemme kolmannen taulun, joka sisältää tiedot katseluista.
Uusi tietokannan rakenne on:

```
sqlite> SELECT * FROM Kayttajat;
id          nimi      
----------  ----------
1           Anna      
2           Maija     
3           Pasi      
```

```
sqlite> SELECT * FROM Videot;
id          nimi          
----------  --------------
1           SQL Tutorial 1
2           SQL Tutorial 2
3           SQL Tutorial 3
4           Karpon parhaat
5           NHK Opening   
```

```
sqlite> SELECT * FROM Katselut;
kayttaja_id  video_id  
-----------  ----------
1            2         
1            4         
1            5         
2            1         
2            4         
3            1         
3            3         
3            5        
```

Nyt voimme hakea mukavasti mitä tahansa tietoa katseluista.
Esimerkiksi seuraava kysely hakee jokaisen videon katselukerrat:

```sql
SELECT V.nimi, COUNT(*) FROM Videot V, Katselut K 
WHERE V.id=K.video_id GROUP BY V.id;
```

```
nimi            COUNT(*)  
--------------  ----------
SQL Tutorial 1  2         
SQL Tutorial 2  1         
SQL Tutorial 3  1         
Karpon parhaat  2         
NHK Opening     2     
```
