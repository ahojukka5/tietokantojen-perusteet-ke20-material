---
path: '/luku-6/3'
title: 'Rinnakkaiset transaktiot'
hidden: false
---

Lisämaustetta transaktioiden käsittelyyn tuo se,
että tietokannalla voi olla useita käyttäjiä,
joilla on meneillään samanaikaisia transaktioita.
Missä määrin eri käyttäjien transaktiot
tulisi eristää toisistaan?

Tämä on kysymys, johon ei ole yhtä oikeaa vastausta,
vaan vastaus riippuu käyttötilanteesta ja myös
tietokannan ominaisuuksista.
Tavallaan olisi paras ratkaisu eristää transaktiot
täydellisesti toisistaan,
mutta toisaalta tämä voi heikentää tietokannan suorituskykyä.

## Transaktiotasot

SQL-standardi määrittelee transaktioiden eristystasot
sen perusteella, millaisia ilmiöitä transaktioissa voi esiintyä.
Ilmiöt ovat:

* _Ilmiö 1_: Transaktio pystyy näkemään toisen transaktion tekemän muutoksen,
  vaikka toista transaktiota ei ole viety loppuun (_dirty read_).
* _Ilmiö 2_: Transaktion sisällä luetaan kahdesti sama rivi,
  mutta rivin sisältö vaihtelee eri kerroilla.
* _Ilmiö 3_: Transaktion sisällä suoritetaan kahdesti sama kysely,
  jonka palauttama rivien joukko vaihtelee eri kerroilla (_phantom read_).
* _Ilmiö 4_: Joukko transaktioita aiheuttaa muutoksia,
  jotka eivät olisi olleet mahdollisia,
  jos transaktiot olisi suoritettu yksi kerrallaan
  toisista erillään.

Ilmiöissä 2–3 kyselyn tulosten muuttuminen voi johtua siitä,
että jokin toinen transaktio on viety loppuun lukukertojen välillä
ja kyseinen transaktio on muuttanut tietokantaa.

Transaktioiden eristystasot heikoimmasta vahvimpaan ovat seuraavat:

* _Taso 1_: Transaktio voi lukea tietoa toisesta transaktiosta,
  jota ei ole viety loppuun, ja kaikki ilmiöt 1–4 ovat mahdollisia (_read uncommitted_).
* _Taso 2_: Transaktio voi lukea vain tietoa, jonka on tallentanut
  jokin lukuhetkellä loppuun viety transaktio, mutta ilmiöt 2–4 ovat mahdollisia (_read committed_).
* _Taso 3_: Jos transaktio lukee kahdesti saman rivin, sen sisältö on varmasti sama,
  mutta ilmiöt 3–4 ovat mahdollisia (_repeatable read_). 
* _Taso 4_: Transaktiot käyttäytyvät samoin kuin jos ne olisi suoritettu yksi
  kerrallaan toisistaan erillisinä eikä mikään ilmiöistä ole mahdollinen (_serializable_).

## Esimerkki

Tarkastellaan tilannetta, jossa tuotteen 1 hinta on aluksi 8
ja kaksi käyttäjää suorittaa samaan aikaan seuraavat transaktiot
(rivin alussa oleva numero ilmaisee, kumman transaktion komennosta on kysymys):

```sql
1 BEGIN TRANSACTION;
2 BEGIN TRANSACTION
2 UPDATE Tuotteet SET hinta=5 WHERE id=1;
1 SELECT hinta FROM Tuotteet WHERE id=1;
2 UPDATE Tuotteet SET hinta=7 WHERE id=1;
2 COMMIT;
1 SELECT hinta FROM Tuotteet WHERE id=1;
1 COMMIT;
```

Tasolla 1 käyttäjä 1 voi saada kyselyistä tulokset 5 ja 7,
koska käyttäjän 2 tekemät muutokset tulevat näkyviin heti,
vaikka käyttäjän 2 transaktioita ei ole viety loppuun.

Tasolla 2 käyttäjä 1 voi saada kyselyistä tulokset 8 ja 7,
koska ensimmäisen kyselyn kohdalla toista transaktiota ei ole viety loppuun,
kun taas toisen kyselyn kohdalla se on viety loppuun.

Tasoilla 3 ja 4 käyttäjä 1 voi saada kyselyistä tulokset 8 ja 8,
koska tämä on tilanne ennen transaktion alkua eikä välissä loppuun viety
transaktio saa muuttaa luettua rivin sisältöä.

## Transaktiot käytännössä

Transaktioiden toteutustavat ja saatavilla olevat eristystasot
vaihtelevat paljon sen mukaan, mikä tietokantajärjestelmä on käytössä.
Esimerkiksi SQLitessä ainoa mahdollinen taso on 4,
kun taas
PostgreSQL toteuttaa tasot 2–4 ja oletuksena käytössä on taso 2.

<text-box variant='hint' name='Miksi eri tasoja käytetään?'>

Eristystaso 4 on tavallaan selkeästi paras,
koska silloin transaktioiden muutokset eivät voi
näkyä mitenkään toisilleen.
Miksi edes muut tasot ovat olemassa ja miksi
esimerkiksi PostgreSQL:n oletustaso on 2?

Hyvän eristämisen hintana on,
että se voi laskea tietokannan suorituskykyä sekä
hidastaa tai estää transaktioiden suorittamista.
Toisaalta monissa tilanteissa käytännössä riittää
mainiosti heikompi eristys.

</text-box>


Hyvää tietoa transaktioiden toiminnasta saa perehtymällä
käytetyn tietokannan dokumentaatioon sekä testailemalla
asioita itse käytännössä.
Esimerkiksi voimme käynnistää itse _kaksi_ SQLite-tulkkia,
avata niillä saman tietokannan ja sen jälkeen
kirjoittaa transaktioita sisältäviä komentoja ja tehdä havaintoja.

Seuraava keskustelu näyttää edellisen esimerkin tuloksen
kahdessa rinnakkain käynnissä olevassa SQLite-tulkissa:

```x
sqlite> BEGIN TRANSACTION;
                                                  sqlite> BEGIN TRANSACTION;
                                                  sqlite> UPDATE Tuotteet SET hinta=5 WHERE id=1;
sqlite> SELECT hinta FROM Tuotteet WHERE id=1;
8
                                                  sqlite> UPDATE Tuotteet SET hinta=7 WHERE id=1;
                                                  sqlite> COMMIT;
                                                  Error: database is locked
sqlite> SELECT hinta FROM Tuotteet WHERE id=1;
8
sqlite> COMMIT;
```

Tästä näkee, että ensimmäinen transaktio tosiaan
saa kummastakin kyselystä tuloksen 8.
Toista transaktiota ei sen sijaan saada vietyä
loppuun, vaan tulee virheviesti `database is locked`,
koska tietokanta on lukittuna samanaikaisen transaktion takia.
Eristys toimii siis hyvin,
mutta toista transaktiota pitäisi yrittää viedä loppuun uudestaan.

Vertailun vuoksi tässä on vastaava keskustelu
PostgreSQL-tulkeissa (tasolla 2):

```x
user=> BEGIN TRANSACTION;
                                                  user=> BEGIN TRANSACTION;
                                                  user=> UPDATE Tuotteet SET hinta=5 WHERE id=1;
user=> SELECT hinta FROM Tuotteet WHERE id=1;
8
                                                  user=> UPDATE Tuotteet SET hinta=7 WHERE id=1;
                                                  user=> COMMIT;
user=> SELECT hinta FROM Tuotteet WHERE id=1;
7
user=> COMMIT;
```

Nyt toisen transaktion muuttama arvo 7
ilmestyy ensimmäiseen transaktioon,
mutta toisaalta molemmat transaktiot
saadaan vietyä loppuun ongelmitta.
